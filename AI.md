# AI 설계 (Function Calling / DB 조회)

이 문서는 **GPT API(Function Calling)** 를 통해, 모델이 필요 시 **주문/채팅 등 DB 데이터를 직접 조회**해서 답변 품질을 높이는 구조를 정리합니다.  
현재는 주문 테이블과 주문 API를 먼저 구축한 상태이며, 이후 단계에서 LLM 호출/툴 실행 루프를 연결합니다.

---

## 목표

1. 고객 메시지 처리 시, GPT가 필요한 경우 주문/배송 상태 등 **사실 기반 데이터**를 조회해 답변한다.
2. 모델은 **DB를 직접 쿼리하지 않고**, 서버가 제공하는 **툴(=함수)** 을 호출해 안전하게 조회한다.
3. 역할 기반 접근 제어(RBAC)로:
   - 고객은 **본인 주문만 조회** 가능
   - 관리자는 **전체 주문 조회** 가능(필요 시)
4. 비용/지연을 최소화하기 위해 `gpt-5-mini` 사용을 기본으로 하고, 컨텍스트를 축소한다.

---

## 환경 변수

- `backend/.env`에 `GPT_API` 로 API 키를 저장한다.
- 사용할 모델: `gpt-5-mini`

> 구현 시 Python SDK를 사용하든, HTTP 호출을 직접 하든 `GPT_API`를 단일 소스로 사용한다.

---

## 추가 요구사항(필수 기능)

### A. 관리자/상담 운영 기능

1. **진행중 채팅의 “AI 요약” 버튼**
   - 버튼 클릭 시, 해당 세션의 **전체 대화 내용을 GPT로 요약**
   - 결과는 즉시 화면에 표시(최소한 `core_summary`, `current_issues`, `action_items` 형태)

2. **채팅 종료 시 자동 요약(저장 + 즉시 확인)**
   - 세션이 `completed`로 전환되는 순간(관리자 종료/AI 자동 종료) GPT가 최종 요약을 생성
   - 생성된 요약을 DB에 저장하고, “상담 완료” 탭에서 바로 확인 가능

3. **처리 대기(pending) 채팅의 사전 요약(미리보기)**
   - pending으로 넘어가는 순간 GPT가 “관리자가 처리해야 할 내용”을 요약해서 저장
   - pending 리스트에서 한 줄 요약/핵심 처리 포인트를 미리 볼 수 있어야 함

4. **관리자 지시(“이렇게 응대해줘”) 반영**
   - 관리자가 “이렇게 응대해줘”라는 형태로 지침을 주면
   - 다음 AI 응답(또는 pending → active 복귀 후 응답)에서 해당 지침을 시스템 컨텍스트로 반영

### B. 고객 응대 품질(사람 개입 최소화)

1. **환불은 즉시 pending으로 넘기지 않기**
   - 환불 의사 표현이 있어도 바로 pending으로 넘기지 않고,
   - GPT가 필요한 정보를 먼저 질문해 수집한 뒤(예: 주문번호/환불 사유/수령 여부 등),
   - “확인 후 *분 이내 답변드리겠습니다.” 멘트와 함께 pending으로 전환

2. **AI가 스스로 종료 판단 및 종료 가능**
   - GPT가 “더 도와드릴 내용이 있으실까요?” 같은 재확인 질문을 한 뒤,
   - 추가 요청이 없다고 판단되면 마무리 멘트와 함께 세션을 `completed` 처리
   - 완료 시 자동 요약 저장 포함

3. **카테고리 자동 설정 + 대화 중 변경 가능**
   - 첫 메시지 시 카테고리를 설정
   - 대화 중 정보가 추가되면 카테고리를 재분류하여 DB에 업데이트

### C. 호출 비용/메시지 끊김 예외

1. **사용자가 여러 번 끊어서 보내는 경우**
   - 메시지가 연속으로 들어오는 경우(예: 1~2초 간격) 매번 GPT를 호출하면 비용이 증가
   - 해결 방안(초안): “디바운스/배치” 처리
     - 마지막 고객 메시지 이후 N초(예: 2초) 동안 추가 입력이 없을 때만 GPT 호출
     - 디바운스 중 새 메시지가 오면 타이머를 리셋
   - 디바운스가 적용되더라도, 최종적으로는 **전체 대화 내용을 매번 GPT에 전달**(요청사항)하며 추후 최적화

---

## 현재 AI 처리 흐름(현 상태)

- `backend/app/services/ai.py`는 키워드 기반 규칙으로:
  - 카테고리 분류
  - 사람 개입 필요 판단
  - 간단한 응답 생성

> 최종 목표 달성 시, 이 로직은 “fallback” 또는 “초기 분류(저비용)” 단계로 남기고, **상세 응답 생성은 GPT + 툴 호출로 전환**한다.

---

## 목표 AI 처리 흐름(향후)

### 1) 메시지 수신(REST)

- 고객: `POST /api/chats/messages`
- 서버는 메시지를 DB에 저장 후, 현재 세션의 `handler_type`에 따라 처리:
  - `handler_type == ai` → GPT 오케스트레이션 실행
  - `handler_type == agent` → AI 자동 응답 없음(관리자/상담원 응대)

### 2) GPT 오케스트레이션(툴 호출 루프)

1. **프롬프트 구성**
   - 시스템: 회사 정책/말투/금지사항/권한 제약
   - 사용자: 고객 메시지
   - 컨텍스트: 사용자와 대화했던 모든 내용, 세션 메타(카테고리/상태), 필요 최소한의 고객 식별 정보(예: 고객 id)

2. **툴 목록 제공**
   - “주문 조회”, “배송 상태 조회”, “주문 검색” 등 서버 함수들을 tool로 제공

3. **응답 생성**
   - 모델이 답변에 주문 정보가 필요하다고 판단하면 tool call을 요청
   - 서버가 tool을 실행(=DB/API 조회) 후 결과를 모델에 전달
   - 모델이 최종 답변 텍스트를 생성

4. **저장 및 브로드캐스트**
   - AI 응답을 `messages` 테이블에 저장
   - WebSocket `new_message`로 고객/관리자에 전달

### 3) 상태 전이(Active ↔ Pending ↔ Completed)

GPT는 매 턴마다 다음 중 하나의 “의사결정”을 출력할 수 있어야 합니다.

- `stay_active`: 계속 AI가 응대
- `to_pending`: 필요한 정보 수집 완료 후 pending 전환 + “*분 이내 답변” 멘트
- `to_completed`: 종료 멘트 + 세션 완료 처리 + 최종 요약 저장

서버는 이 결정을 검증하고(권한/조건), DB 업데이트 및 WS 이벤트를 발행합니다.

### 3) 비용/지연 제어

- 기본 모델: `gpt-5-mini`
- tool call 루프 최대 횟수 제한(예: 3회)
- 최근 메시지 window 제한(예: 20개)
- 응답 길이 제한, 불필요한 데이터(전체 주문 리스트 등) 제한

---

## 툴(함수) 설계

모델은 DB에 직접 접근하지 않고, 서버가 제공하는 “툴”을 통해서만 조회합니다.  
툴은 **입력 검증**, **권한 검사**, **결과 정규화**를 수행하고, 모델에게는 필요한 최소 필드만 전달합니다.

### 공통 원칙

- 고객 role에서:
  - `customer_id`는 토큰에서 결정(모델이 임의 고객 id를 지정할 수 없음)
  - `order_number`는 고객이 제공한 값만 허용(추측 조회 금지)
- 관리자 role에서:
  - 범위가 넓으므로 쿼리 제한(페이지네이션/limit) 필수
- 개인정보 최소화:
  - 이메일/전화 등 PII는 필요 시에만 전달
  - 기본적으로는 `order_number`, `product_name`, `shipping_status`, `ordered_at` 중심

---

## 1차로 연결할 툴 후보(주문/배송)

> 아래는 “GPT가 DB 조회를 할 수 있게” 만드는 최소 시작 세트입니다.

### (Customer) `get_my_order(order_number)`
- 목적: 고객이 제공한 주문번호의 배송 상태/상품명 확인
- 권한: 고객 본인 주문만
- 반환: `{order_number, product_name, shipping_status, ordered_at}`

### (Customer) `list_my_orders(status?)`
- 목적: “최근 주문 뭐였지?” 같은 질문 대응
- 권한: 고객 본인 주문만
- 제한: 기본 10건(최근순), 필요 시 페이징

### (Admin) `admin_get_order(order_number)`
- 목적: 상담원이 주문번호로 조회해 고객 안내
- 반환: `{order_number, product_name, customer_id, shipping_status, ordered_at}`

### (Admin) `admin_list_orders(filters...)`
- 목적: 고객/상태 기준 검색
- 제한: limit/pagination 필수

---

## 2차로 연결할 툴 후보(채팅/세션)

주문 조회 외에도, 상담 품질을 위해 다음 툴이 유용합니다.

- `get_chat_session(session_id)` : 현재 상담 상태/카테고리/핸들러 타입
- `list_recent_messages(session_id, limit)` : 최근 대화 컨텍스트 제공(필요 최소)
- `get_company_policy()` / `get_faq()` : 사내 정책/FAQ를 구조화해서 제공

---

## 프롬프트 가이드(초안)

### System(요약)
- 너는 고객 상담 AI이다.
- 사실 확인이 필요한 경우, 반드시 제공된 tool을 호출해 조회한다.
- 조회 결과가 없으면 “확인 불가”를 명확히 말하고 추가 정보를 요청한다.
- 고객에게 내부 구현(AI/상담원 구분, tool 사용, DB 등)을 노출하지 않는다.
- 개인정보는 최소한으로 사용하고 출력하지 않는다.

### Tool 사용 예시(개념)
- 고객이 “ORD-2025-0001 배송 어디까지?” → `get_my_order(order_number="ORD-2025-0001")`
- 고객이 “내 주문 내역 알려줘” → `list_my_orders()`

---

## 구현 단계(체크리스트)

1. (완료) 주문 테이블/주문 API 구축
2. GPT 클라이언트 모듈 추가 (키: `GPT_API`, 모델: `gpt-5-mini`)
3. “대화 전체 기반” 요약기 구현
   - (Admin) 진행중 요약 버튼 → GPT 요약
   - (System) 종료 시 자동 요약 저장
   - (System) pending 전환 시 처리 포인트 요약 저장
4. 대화 응답 오케스트레이터 구현(상태 전이 포함)
   - 카테고리 추론/변경
   - 환불 정보 수집(즉시 pending 금지)
   - 자동 종료 판단 및 종료
   - 관리자 지시 반영
5. Tool 함수(주문 조회 등) 서버 내부 함수로 구현 (권한/검증 포함)
6. GPT 호출 + tool loop 오케스트레이터 연결
7. 메시지 디바운스/배치(끊어서 보내는 입력 대응)
8. 로깅/레이트리밋/에러 핸들링/비용 제어 추가
